class Board {
    field Array cells;
    field int width, height, mineCount, cursorX, cursorY, flaggedMines, flagged;

    constructor Board new(){
        let width = 10;
        let height = 10;
        let cursorX = 0;
        let cursorY = 0;
        let flagged = 0;
        let cells = Array.new(width * height);
        
        /* в конструкторе можно менять только число мин! :) под изменения размеров поля UI не настроен  */
        let mineCount = 10;

        do InitializeBoard();
        do CalculateNumbers();
        return this;
    }

    method void InitializeBoard(){
        var int i, index;
        var Cell cell;
        let i = 0;
        while (i < (width * height)) {
            let cell = Cell.new(i);
            let cells[i] = cell;
            do UI.RenderClosedCell(cell);
            let i = i + 1;
        }
        let i = 0;
        while(i < mineCount){
            let index = Random.Randint(width * height);
            let cell = cells[index];
            if (~cell.IsMine()){
                do cell.PlaceMine();
                let i = i + 1;
            }
        }
        return;
    }

    method void CalculateNumbers() {
        var int i, j, x, y, index, count;
        var Cell cell;
        let i = 0;
        while (i < width) {
            let j = 0;
            while (j < height) {
                let index = i * width + j;
                let count = 0;
                let cell = cells[index];
                if (~cell.IsMine()) {
                    let x = -1;
                    while (x < 2) {
                        let y = -1;
                        while (y < 2) {
                            if (((i + x) > -1) & ((i + x) < width) & ((j + y) > -1) & ((j + y) < height)) {
                                let cell = cells[(i + x) * width + (j + y)];
                                if (cell.IsMine()) {
                                    let count = count + 1;
                                }
                            }
                            let y = y + 1;
                        }
                        let x = x + 1;
                    }
                    do cell.SetAdjasent(count);
                }
                let j = j + 1;
            }
            let i = i + 1;
        }
        return;
    }
    
    method void RenderCell(int x, int y) {
        var Cell cell;
        let cell = cells[y * width + x];
        if(~cell.IsRevealed()){
            if(cell.IsFlagged()){
                do UI.RenderFlag(cell);
            }
            else{ 
                do UI.RenderClosedCell(cell); 
            }
        }
        else{ 
            do UI.RenderOpenCell(cell);
        }
        return;
    }

    method void RevealCell(int x, int y) {
        var Cell cell;
        let cell = cells[y * width + x];
        if ((~cell.IsRevealed()) & (~cell.IsFlagged())) {
            do cell.RevealCell();
        }
        return;
    }

    method void ToggleFlag(int x, int y){
        var Cell cell;
        let cell = cells[y * width + x];
        if (~cell.IsRevealed()) {
            if (cell.IsMine()){
                if (cell.IsFlagged()){
                    let flaggedMines = flaggedMines - 1;
                }
                else{
                    let flaggedMines = flaggedMines + 1;
                }
            }
            if(cell.IsFlagged()){
                let flagged = flagged - 1;
            }
            else{
                let flagged = flagged + 1;
            }
            do cell.ChangeFlag();
        }
        return;
    }

    method void MoveCursorX(int x){
        if ((cursorX + x < 50) & (cursorX + x > 0)){
            let cursorX = cursorX + x;
        }
        return;
    }

    method void MoveCursorY(int y){
        if ((cursorY + y < 50) & (cursorY + y > 0)){
            let cursorY = cursorY + y;
        }
        return;
    }

    method int GetCursorX(){
        return (cursorX / 5) + 1;
    }

    method int GetCursorY(){
        return (cursorY / 5) + 1;
    }

    method boolean IsWin(){
        return (flaggedMines = mineCount) & (mineCount = flagged);
    }

    method boolean IsLoss(){
        var boolean isLoss;
        var int i;
        var Cell cell;
        let i = 0;
        let isLoss = false;
        while(i < (width * height)){
            let cell = cells[i];
            if(cell.IsRevealed() & cell.IsMine()){
                let isLoss = true;
                let i = width * height;
            }
            let i = i + 1;
        }
        return isLoss;
    }
}
